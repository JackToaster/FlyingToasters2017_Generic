package simulation;

import java.util.HashMap;

import utilities.Utilities.Conversions.Distance;

import simulation.PDPJNI;
public class SimMotor {
	
	public static HashMap<Integer,MotorInfo> motors;
	
	public SimMotor(){
		motors = new HashMap<Integer, MotorInfo>();
	}
	
	public void addMotor(int id, double acceleration, double maxVel, int pdpPort) {
		MotorInfo newMotor = new MotorInfo(acceleration, maxVel);
		motors.put((Integer) id, newMotor);
		PDPJNI.addMotor((byte) pdpPort, (Integer) id);
	}
	
	public void updateMotors(double dT){
		for(Integer i : motors.keySet()){
			MotorInfo current = motors.get(i);
			current.update(dT);
			motors.put(i, current);
		}
	}
	
	public class MotorInfo{
		//default winding resistance and back-emf constant based on CIM motor.
		//winding resistance: resistance in motor windings
		private double windingResistance = 0.0125;
		//back-emf constant - amount of backwards voltage generated by spinning rotor.
		private double Kbemf = 0.125;
		//the minimum amount of throttle to move
		//TODO make it work
		//private double minThrottle = 0.05;
		private double accel;
		private double maxVel;
		private double currentAmps = 0;
		private double vel;
		private double throttle;
		private double position;
		public MotorInfo(double acceleration, double maxVelocity){
			position = 0;
			throttle = 0;
			vel = 0;
			maxVel = maxVelocity;
			accel = acceleration;
		}
	
		public void setThrottle(double throttle){
			if(throttle > 1) this.throttle = 1;
			else if(throttle < -1) this.throttle = -1;
			else this.throttle = throttle;
		}
		public void update(double dT){
			double diff = (throttle * maxVel) - vel;
			double impulse = accel * dT;
			if(Math.abs(diff) < impulse) {
				vel = throttle * maxVel;
			}else {
				if(vel > throttle * maxVel) {
					if(vel > 0) {
						vel -= impulse;
					}else {
						vel -= impulse;
					}
				}else {
					if(vel < 0) {
						vel += impulse;
					}else {
						vel += impulse;
					}
				}
			}
			
			position += vel * dT;
			limitSpeed();
			//just for test, not accurate in any way.
			currentAmps = Math.abs(throttle * 12.0 - vel * Kbemf)/windingResistance;
		}
		public int getPos(){
			return (int) Distance.M.convert(position, Distance.ENCODER_TICK);
		}
		public void limitSpeed(){
			if(Math.abs(vel) > maxVel){
				if(vel > 0){
					vel = maxVel;
				}else{
					vel = -maxVel;
				}
			}
		}
		
		public double getCurrent(){
			return currentAmps;
		}
		
		public String toString(){
			return "\nPosition: " + position + ", velocity: " + vel + ", current: " + currentAmps;
		}
	}
}
